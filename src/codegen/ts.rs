use crate::ast::{Query, QueryFile};
use crate::schema::{Column, Index, Partition, Schema, Table, TableConstraint};

pub fn generate_ts(query_file: &QueryFile, schema: Option<&Schema>) -> String {
    let mut output = String::new();

    output.push_str("// Auto-generated TypeScript types and functions\n");
    output.push_str("// Generated by Stratus TypeSQL Compiler (PostgreSQL)\n\n");

    // Generate schema-based types
    if let Some(schema) = schema {
        output.push_str("// ==================== Schema Types ====================\n\n");

        for (table_name, table) in &schema.tables {
            let pascal_name = to_pascal_case(table_name);
            output.push_str(&format!("// Table: {}\n", table_name));
            output.push_str(&format!("export interface {} {{\n", pascal_name));

            for (col_name, col) in &table.columns {
                let ts_type = map_sql_type_to_ts(col);
                let optional = if !col.is_not_null() && !col.is_primary_key() {
                    "?"
                } else {
                    ""
                };
                output.push_str(&format!("  {}{}: {};\n", col_name, optional, ts_type));
            }
            output.push_str("}\n\n");

            // Generate Insert type
            output.push_str(&format!(
                "export type Insert{} = Partial<{}>;\n\n",
                pascal_name, pascal_name
            ));

            // Generate Table info
            if !table.indexes.as_ref().map(|i| i.is_empty()).unwrap_or(true)
                || !table
                    .constraints
                    .as_ref()
                    .map(|c| c.is_empty())
                    .unwrap_or(true)
            {
                output.push_str(&format!("// Indexes for {}\n", pascal_name));
                if let Some(indexes) = &table.indexes {
                    for index in indexes {
                        output.push_str(&format!(
                            "//   Index: {} ({})\n",
                            index.name,
                            index.columns.join(", ")
                        ));
                    }
                }
                output.push_str("\n");
            }
        }

        // Generate enums
        if let Some(enums) = &schema.enums {
            output.push_str("// ==================== Enums ====================\n\n");
            for (enum_name, values) in enums {
                let pascal_name = to_pascal_case(enum_name);
                output.push_str(&format!("export type {} = ", pascal_name));
                for (i, v) in values.iter().enumerate() {
                    if i > 0 {
                        output.push_str(" | ");
                    }
                    output.push_str(&format!("'{}'", v));
                }
                output.push_str(";\n\n");
            }
        }

        // Generate partitioned tables info
        let partitioned_tables: Vec<_> = schema
            .tables
            .iter()
            .filter(|(_, t)| !t.partitions.is_empty())
            .collect();
        if !partitioned_tables.is_empty() {
            output.push_str("// ==================== Partitioned Tables ====================\n\n");
            for (table_name, table) in partitioned_tables {
                let pascal_name = to_pascal_case(table_name);
                output.push_str(&format!("export interface {}Partition {{\n", pascal_name));
                output.push_str(&format!("  partition_name: string;\n"));
                output.push_str(&format!("  partition_values: string;\n"));
                output.push_str("}\n\n");
            }
        }
    }

    // Generate query parameter interfaces
    output.push_str("// ==================== Query Parameters ====================\n\n");
    for query in &query_file.queries {
        let param_interface_name = format!("{}Params", query.name);
        output.push_str(&format!("export interface {} {{\n", param_interface_name));
        if query.params.is_empty() {
            output.push_str("  // No parameters\n");
        } else {
            for param in &query.params {
                let ts_type = map_param_type_to_ts(&param.type_);
                output.push_str(&format!("  {}: {};\n", param.name, ts_type));
            }
        }
        output.push_str("}\n\n");
    }

    // Generate query result types
    output.push_str("// ==================== Query Results ====================\n\n");
    for query in &query_file.queries {
        // Use JOIN-aware type generation
        if let Some(schema) = schema {
            let result_type = generate_query_result_type(&query.name, &query.sql, schema);
            output.push_str(&result_type);
            output.push_str("\n");
        } else {
            let return_type_name = format!("{}Result", query.name);
            output.push_str(&format!("export type {} = {{\n", return_type_name));
            output.push_str("  // Schema required for type inference\n");
            output.push_str("  [key: string]: unknown;\n");
            output.push_str("};\n\n");
        }
    }

    // Generate query registry
    output.push_str("// ==================== Query Registry ====================\n\n");
    output.push_str("export const queries = {\n");
    for query in &query_file.queries {
        let param_interface_name = format!("{}Params", query.name);
        let return_type_name = format!("{}Result", query.name);
        output.push_str(&format!("  {}: {{\n", query.name));
        output.push_str(&format!("    sql: `{}`,\n", query.sql.replace("`", "\\`")));
        output.push_str(&format!(
            "    params: {} as unknown as {},\n",
            if query.params.is_empty() {
                "undefined"
            } else {
                "{}"
            },
            param_interface_name
        ));
        output.push_str(&format!(
            "    result: null as unknown as {},\n",
            return_type_name
        ));
        output.push_str(&format!("  }},\n"));
    }
    output.push_str("} as const;\n\n");

    // Generate execute stub
    output.push_str("// ==================== Database Driver ====================\n\n");
    output.push_str("export async function execute<T>(\n");
    output.push_str("  sql: string,\n");
    output.push_str("  params: unknown[]\n");
    output.push_str("): Promise<T> {\n");
    output.push_str("  // TODO: Connect to native PostgreSQL driver (pg, node-postgres)\n");
    output.push_str("  throw new Error('Not implemented: connect to PostgreSQL driver');\n");
    output.push_str("}\n\n");

    // Generate type-safe query functions
    output.push_str("// ==================== Type-Safe Query Functions ====================\n\n");
    for query in &query_file.queries {
        let param_interface_name = format!("{}Params", query.name);
        let return_type_name = format!("{}Result", query.name);
        output.push_str(&format!(
            "export async function {}({}: {}): Promise<{}> {{\n",
            to_camel_case(&query.name),
            if query.params.is_empty() {
                "_params"
            } else {
                "params"
            },
            param_interface_name,
            return_type_name
        ));
        output.push_str(&format!(
            "  const sql = `{}`;\n",
            query.sql.replace("`", "\\`")
        ));
        if query.params.is_empty() {
            output.push_str("  return execute(sql, []);\n");
        } else {
            output.push_str("  const params = [\n");
            for param in &query.params {
                output.push_str(&format!(
                    "    params.{}, // ${{{}}}\n",
                    param.name, param.ordinal
                ));
            }
            output.push_str("  ];\n");
            output.push_str("  return execute(sql, params);\n");
        }
        output.push_str("}\n\n");
    }

    output
}

pub fn generate_ts_types_only(schema: &Schema) -> String {
    let mut output = String::new();

    output.push_str("// Auto-generated TypeScript types from PostgreSQL schema\n");
    output.push_str("// Generated by Stratus TypeSQL Compiler\n\n");

    for (table_name, table) in &schema.tables {
        let pascal_name = to_pascal_case(table_name);

        // Table JSDoc
        output.push_str(&format!("/**\n"));
        output.push_str(&format!(" * Table: {}\n", table_name));
        if let Some(options) = &table.options.tablespace {
            output.push_str(&format!(" * Tablespace: {}\n", options));
        }
        if !table.inherits.is_empty() {
            output.push_str(&format!(" * Inherits: {}\n", table.inherits.join(", ")));
        }
        output.push_str(" */\n");

        // Generate table interface
        output.push_str(&format!("export interface {} {{\n", pascal_name));

        for (col_name, col) in &table.columns {
            let ts_type = map_sql_type_to_ts(col);
            let optional = if !col.is_not_null() && !col.is_primary_key() {
                "?"
            } else {
                ""
            };

            // Column JSDoc
            let mut flags: Vec<String> = Vec::new();
            if col.is_primary_key() {
                flags.push("PK".to_string());
            }
            if col.is_unique() {
                flags.push("UNIQUE".to_string());
            }
            if col.identity.is_some() {
                flags.push("IDENTITY".to_string());
            }
            if col.generated.is_some() {
                flags.push("GENERATED".to_string());
            }
            if let Some(ref coll) = col.collation {
                flags.push(format!("collate: {}", coll));
            }
            if col.is_not_null() {
                flags.push("NOT NULL".to_string());
            }

            let flag_str = if flags.is_empty() {
                String::new()
            } else {
                format!(" // {}", flags.join(", "))
            };

            output.push_str(&format!(
                "  {}{}: {};{}\n",
                col_name, optional, ts_type, flag_str
            ));
        }
        output.push_str("}\n\n");

        // Generate Insert type
        output.push_str(&format!(
            "/** Insert type for {} - all fields optional */\n",
            pascal_name
        ));
        output.push_str(&format!(
            "export type Insert{} = Partial<{}>;\n\n",
            pascal_name, pascal_name
        ));

        // Generate Index types
        if let Some(indexes) = &table.indexes {
            if !indexes.is_empty() {
                output.push_str(&format!("// Indexes for {}\n", pascal_name));
                for index in indexes {
                    let index_type_name =
                        format!("{}Index{}", pascal_name, to_pascal_case(&index.name));
                    output.push_str(&format!(
                        "/** Index: {} (columns: {}, method: {:?}) */\n",
                        index.name,
                        index.columns.join(", "),
                        index.method
                    ));
                    output.push_str(&format!("export type {} = {{\n", index_type_name));
                    output.push_str(&format!("  name: '{}';\n", index.name));
                    output.push_str(&format!(
                        "  columns: [{}];\n",
                        index
                            .columns
                            .iter()
                            .map(|c| format!("'{}'", c))
                            .collect::<Vec<_>>()
                            .join(", ")
                    ));
                    output.push_str(&format!("  unique: {};\n", index.unique));
                    if let Some(ref with_opts) = index.with {
                        output.push_str("  with: {\n");
                        if let Some(ff) = with_opts.fillfactor {
                            output.push_str(&format!("    fillfactor: {};\n", ff));
                        }
                        if let Some(dd) = with_opts.deduplicate_items {
                            output.push_str(&format!("    deduplicateItems: {};\n", dd));
                        }
                        if let Some(fu) = with_opts.fastupdate {
                            output.push_str(&format!("    fastupdate: {};\n", fu));
                        }
                        output.push_str("  };\n");
                    }
                    if let Some(ref where_clause) = index.where_clause {
                        output.push_str(&format!("  where: '{}';\n", where_clause));
                    }
                    output.push_str("};\n\n");
                }
            }
        }
    }

    // Generate enums
    if let Some(enums) = &schema.enums {
        output.push_str("// ==================== Enums ====================\n\n");
        for (enum_name, values) in enums {
            let pascal_name = to_pascal_case(enum_name);
            output.push_str(&format!("/** Enum: {} */\n", enum_name));
            output.push_str(&format!("export type {} = ", pascal_name));
            for (i, v) in values.iter().enumerate() {
                if i > 0 {
                    output.push_str(" | ");
                }
                output.push_str(&format!("'{}'", v));
            }
            output.push_str(";\n\n");
        }
    }

    // Generate relations type hint
    output.push_str("// ==================== Relations ====================\n\n");
    output.push_str("/**\n");
    output.push_str(" * To use relations, include this in your query:\n");
    output.push_str(" * ```ts\n");
    output.push_str(" * const users = await db.query.users.findMany({\n");
    output.push_str(" *   with: {\n");
    output.push_str(" *     orders: true,  // relations defined in schema\n");
    output.push_str(" *   },\n");
    output.push_str(" * });\n");
    output.push_str(" * ```\n");
    output.push_str(" */\n");

    output
}

fn map_sql_type_to_ts(col: &Column) -> String {
    let base_type = col.data_type.to_lowercase();
    let is_array = col.array_dimensions.is_some();

    let result = match base_type.as_str() {
        "serial" | "bigserial" | "integer" | "int" | "int4" | "int8" | "bigint" | "smallint" => {
            "number"
        }
        "float" | "double precision" | "real" | "decimal" | "numeric" => "number",
        "varchar" | "char" | "bpchar" | "text" => "string",
        "boolean" | "bool" => "boolean",
        "date"
        | "timestamp"
        | "timestamptz"
        | "timestamp with time zone"
        | "timestamp without time zone"
        | "time"
        | "timetz" => "Date",
        "interval" => "string",
        "json" => "Record<string, unknown>",
        "jsonb" => "Record<string, unknown>",
        "uuid" => "string",
        "xml" => "string",
        "bytea" => "Uint8Array",
        "cidr" | "inet" | "macaddr" | "macaddr8" => "string",
        "point" | "line" | "lseg" | "box" | "path" | "polygon" | "circle" => "string",
        "tsvector" => "string",
        "tsquery" => "string",
        "hstore" => "Record<string, unknown>",
        "ltree" => "string",
        "money" => "number",
        "any" | "anyelement" | "anyarray" | "anynonarray" | "anyenum" | "anyrange" => "unknown",
        _ => "unknown",
    };

    if is_array {
        format!("{}[]", result)
    } else {
        result.to_string()
    }
}

fn map_param_type_to_ts(sql_type: &str) -> &str {
    match sql_type.to_lowercase().as_str() {
        "number" | "int" | "integer" | "float" | "double" | "decimal" => "number",
        "text" | "string" | "varchar" | "char" => "string",
        "boolean" | "bool" => "boolean",
        "date" | "timestamp" | "datetime" => "Date",
        "json" => "unknown",
        _ => "unknown",
    }
}

fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize = true;
    for c in s.chars() {
        if c == '_' {
            capitalize = true;
        } else if capitalize {
            result.push(c.to_ascii_uppercase());
            capitalize = false;
        } else {
            result.push(c);
        }
    }
    result
}

fn to_camel_case(s: &str) -> String {
    let pascal = to_pascal_case(s);
    let mut chars = pascal.chars();
    match chars.next() {
        Some(c) => c.to_lowercase().to_string() + chars.as_str(),
        None => String::new(),
    }
}

fn extract_table_from_query(sql: &str) -> Option<String> {
    let sql_lower = sql.to_lowercase();
    if let Some(from_pos) = sql_lower.find("from") {
        let after_from = &sql[from_pos + 4..];
        let tokens: Vec<&str> = after_from.split_whitespace().collect();
        if !tokens.is_empty() {
            let table = tokens[0].trim_matches(|c| c == '"' || c == '`' || c == '\'');
            return Some(table.to_string());
        }
    }
    None
}

/// Generate query result type with JOIN support
pub fn generate_query_result_type(query_name: &str, sql: &str, schema: &Schema) -> String {
    use crate::parser::{extract_select_columns, extract_tables_from_sql};

    let tables = extract_tables_from_sql(sql);
    let columns = extract_select_columns(sql);

    let return_type_name = format!("{}Result", query_name);

    // If we have schema and tables/columns, generate proper type
    if !tables.is_empty() && !columns.is_empty() {
        let mut result = format!("export type {} = {{\n", return_type_name);

        // Track used property names to detect conflicts
        let mut used_property_names: std::collections::HashSet<String> =
            std::collections::HashSet::new();
        // Track full column path for deduplication
        let mut processed_columns: std::collections::HashSet<String> =
            std::collections::HashSet::new();

        for col in &columns {
            // Handle table.* wildcard
            if col.is_wildcard && col.table_name.is_some() {
                let table_name = col.table_name.as_ref().unwrap();
                if let Some(table) = schema.tables.get(table_name) {
                    for (col_name, column) in &table.columns {
                        let key = format!("{}.{}", table_name, col_name);
                        if !processed_columns.contains(&key) {
                            processed_columns.insert(key);
                            let ts_type = map_sql_type_to_ts(column);
                            let optional = if !column.is_not_null() && !column.is_primary_key() {
                                "?"
                            } else {
                                ""
                            };
                            // Use alias format for JOIN results, handle conflicts with table prefix
                            let property_name = get_unique_property_name(
                                col_name,
                                table_name,
                                &mut used_property_names,
                            );
                            result.push_str(&format!("  /** From {} */\n", table_name));
                            result.push_str(&format!("  {}?: {};\n", property_name, ts_type));
                        }
                    }
                }
            }
            // Handle * wildcard (all tables)
            else if col.is_wildcard && col.table_name.is_none() {
                for table_name in &tables {
                    if let Some(table) = schema.tables.get(table_name) {
                        for (col_name, column) in &table.columns {
                            let key = format!("{}.{}", table_name, col_name);
                            if !processed_columns.contains(&key) {
                                processed_columns.insert(key);
                                let ts_type = map_sql_type_to_ts(column);
                                let optional = if !column.is_not_null() && !column.is_primary_key()
                                {
                                    "?"
                                } else {
                                    ""
                                };
                                let property_name = get_unique_property_name(
                                    col_name,
                                    table_name,
                                    &mut used_property_names,
                                );
                                result.push_str(&format!("  /** From {} */\n", table_name));
                                result.push_str(&format!("  {}?: {};\n", property_name, ts_type));
                            }
                        }
                    }
                }
            }
            // Handle specific column (table.column or column)
            else {
                let table_name = col.table_name.clone().or_else(|| {
                    // If no table specified, find from tables list
                    tables.first().cloned()
                });

                if let Some(tname) = table_name {
                    if let Some(table) = schema.tables.get(&tname) {
                        if let Some(column) = table.columns.get(&col.column_name) {
                            let ts_type = map_sql_type_to_ts(column);
                            let optional = if !column.is_not_null() && !column.is_primary_key() {
                                "?"
                            } else {
                                ""
                            };
                            let source = if col.table_name.is_some() {
                                format!("From {}", col.table_name.as_ref().unwrap())
                            } else {
                                "Default".to_string()
                            };
                            let property_name = get_unique_property_name(
                                &col.column_name,
                                &tname,
                                &mut used_property_names,
                            );
                            result.push_str(&format!("  /** {} */\n", source));
                            result.push_str(&format!("  {}?: {};\n", property_name, ts_type));
                        } else {
                            // Column not found in schema
                            let property_name = get_unique_property_name(
                                &col.column_name,
                                &tname,
                                &mut used_property_names,
                            );
                            result.push_str(&format!(
                                "  /** {} (unknown type) */\n  {}?: unknown;\n",
                                col.column_name, property_name
                            ));
                        }
                    } else {
                        // Table not found
                        let property_name = get_unique_property_name(
                            &col.column_name,
                            &tname,
                            &mut used_property_names,
                        );
                        result.push_str(&format!(
                            "  /** {} (table not found) */\n  {}?: unknown;\n",
                            col.column_name, property_name
                        ));
                    }
                }
            }
        }

        result.push_str("};\n");
        result
    } else {
        // Fallback to schema inference for single table
        if let Some(table_name) = tables.first() {
            if let Some(table) = schema.tables.get(table_name) {
                let mut result = format!("export type {} = {{\n", return_type_name);
                let mut used_property_names: std::collections::HashSet<String> =
                    std::collections::HashSet::new();
                for (col_name, column) in &table.columns {
                    let ts_type = map_sql_type_to_ts(column);
                    let optional = if !column.is_not_null() && !column.is_primary_key() {
                        "?"
                    } else {
                        ""
                    };
                    result.push_str(&format!("  {}{}: {};\n", col_name, optional, ts_type));
                }
                result.push_str("};\n");
                result
            } else {
                format!(
                    "export type {} = Record<string, unknown>;\n",
                    return_type_name
                )
            }
        } else {
            format!(
                "export type {} = Record<string, unknown>;\n",
                return_type_name
            )
        }
    }
}

/// Get a unique property name, adding table prefix if there's a conflict
fn get_unique_property_name(
    column_name: &str,
    table_name: &str,
    used_names: &mut std::collections::HashSet<String>,
) -> String {
    let mut property_name = column_name.to_string();
    let mut counter = 1;

    while used_names.contains(&property_name) {
        // Conflict detected, use table prefix with counter
        property_name = format!("{}_{}_{}", table_name, column_name, counter);
        counter += 1;
    }

    used_names.insert(property_name.clone());
    property_name
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("users"), "Users");
        assert_eq!(to_pascal_case("user_posts"), "UserPosts");
    }

    #[test]
    fn test_to_camel_case() {
        assert_eq!(to_camel_case("GetUser"), "getUser");
        assert_eq!(to_camel_case("ListUsers"), "listUsers");
    }

    #[test]
    fn test_get_unique_property_name_no_conflict() {
        let mut used = std::collections::HashSet::new();
        assert_eq!(get_unique_property_name("id", "users", &mut used), "id");
        assert!(used.contains("id"));
    }

    #[test]
    fn test_get_unique_property_name_with_conflict() {
        let mut used = std::collections::HashSet::new();
        used.insert("id".to_string());
        assert_eq!(
            get_unique_property_name("id", "orders", &mut used),
            "orders_id_1"
        );
        assert!(used.contains("orders_id_1"));
    }

    #[test]
    fn test_get_unique_property_name_multiple_conflicts() {
        let mut used = std::collections::HashSet::new();
        used.insert("id".to_string());
        used.insert("orders_id".to_string());
        // This would create another conflict, so we'd get orders_id again
        // but since it's already used, it would continue
        let result = get_unique_property_name("id", "orders", &mut used);
        assert!(result.starts_with("orders_id"));
    }

    #[test]
    fn test_generate_query_result_type_with_join_conflicts() {
        use crate::schema::{Column, Schema, Table};

        let mut tables = std::collections::HashMap::new();
        let mut users_cols = std::collections::HashMap::new();
        users_cols.insert(
            "id".to_string(),
            Column {
                data_type: "integer".to_string(),
                ..Default::default()
            },
        );
        users_cols.insert(
            "email".to_string(),
            Column {
                data_type: "varchar".to_string(),
                ..Default::default()
            },
        );
        tables.insert(
            "users".to_string(),
            Table {
                columns: users_cols,
                ..Default::default()
            },
        );

        let mut orders_cols = std::collections::HashMap::new();
        orders_cols.insert(
            "id".to_string(),
            Column {
                data_type: "integer".to_string(),
                ..Default::default()
            },
        );
        orders_cols.insert(
            "user_id".to_string(),
            Column {
                data_type: "integer".to_string(),
                ..Default::default()
            },
        );
        orders_cols.insert(
            "total".to_string(),
            Column {
                data_type: "decimal".to_string(),
                ..Default::default()
            },
        );
        tables.insert(
            "orders".to_string(),
            Table {
                columns: orders_cols,
                ..Default::default()
            },
        );

        let schema = Schema {
            tables,
            ..Default::default()
        };

        let sql = "SELECT users.*, orders.* FROM users JOIN orders ON users.id = orders.user_id";
        let result = generate_query_result_type("GetUserWithOrders", sql, &schema);

        // Should have:
        // - id from users (no prefix, first occurrence)
        // - email from users (no prefix)
        // - user_id from orders (no prefix, not conflicting)
        // - total from orders (no prefix)
        // - orders_id_1 from orders (duplicate id gets prefix)
        assert!(
            result.contains("id?: number"),
            "First id should be plain 'id'"
        );
        assert!(
            result.contains("orders_id_1"),
            "Second id should be orders_id_1"
        );
        assert!(
            result.contains("email?: string"),
            "Should have users.email as email"
        );
        assert!(
            result.contains("user_id?: number"),
            "Should have orders.user_id as user_id"
        );
        assert!(
            result.contains("total?: number"),
            "Should have orders.total as total"
        );
    }
}
